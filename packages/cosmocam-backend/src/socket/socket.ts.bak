import https from "https";
import { Server } from "socket.io";
import { types as mediasoupTypes } from "mediasoup";
import { StreamManagerSingleton } from "../models/StreamManager/StreamManagerSingleton";
import { getLocalIPAddress, log, mediaCodecs } from "./util";
const mediasoup = require("mediasoup");

const handleSocketDisconnect = (socket: any) => {
  console.log(`Socket Disconnected: ${socket.id}`);
};

export const socketSetup = (httpsServer: https.Server) => {
  const io = new Server(httpsServer);
  let streamManager = StreamManagerSingleton.getStreamManager();

  let worker: mediasoupTypes.Worker;
  let router: mediasoupTypes.Router;
  let producer: mediasoupTypes.Producer;
  let consumer: mediasoupTypes.Consumer;
  let producerTransport: mediasoupTypes.WebRtcTransport;
  let consumerTransport: mediasoupTypes.WebRtcTransport;

  const getRtpCapabilities = (callback: ({}) => void) => {
    const rtpCapabilities = router.rtpCapabilities;
    callback({ rtpCapabilities });
  };

  const createWorker = async (): Promise<mediasoupTypes.Worker> => {
    worker = await mediasoup.createWorker({
      logLevel: "warn",
      rtcMinPort: 2000,
      rtcMaxPort: 2100,
    });
    log(`worker pid ${worker.pid}`);

    worker.on("died", (error) => {
      log("mediasoup worker has died");
      setTimeout(() => process.exit(1), 2000); // exit in 2 seconds
    });

    return worker;
  };

  createWorker().then((data) => {
    worker = data;
  });

  const createWebRtcTransport = async (callback: any) => {
    try {
      const localIPAddress: string = getLocalIPAddress();
      const webRtcTransport_options = {
        listenIps: [{ ip: localIPAddress }],
        enableUdp: true,
        enableTcp: true,
        preferUdp: true,
      };
      let transport = await router.createWebRtcTransport(
        webRtcTransport_options
      );

      log(`transport id: ${transport.id}`);

      transport.on("dtlsstatechange", (dtlsState: any) => {
        if (dtlsState === "closed") {
          transport.close();
        }
      });

      transport.on("@close", () => {
        log("transport closed");
      });

      callback({
        params: {
          id: transport.id,
          iceParameters: transport.iceParameters,
          iceCandidates: transport.iceCandidates,
          dtlsParameters: transport.dtlsParameters,
        },
      });

      return transport;
    } catch (error) {
      log(error);
    }
  };

  const peers = io.of("/mediasoup");

  peers.on("connection", async (socket) => {
    log(`socket connected: ${socket.id}`);
    socket.emit("connection-success", {
      socketId: socket.id,
    });

    socket.on("disconnect", () => handleSocketDisconnect(socket));

    socket.on("createRoom", async (callback) => {
      if (router === undefined) {
        log("New Router Created");
        router = await worker.createRouter({ mediaCodecs });
        log(`Router ID: ${router.id}`);
      }

      getRtpCapabilities(callback);
    });

    socket.on("getRtpCapabilities", (callback) => {
      const rtpCapabilities = router?.rtpCapabilities;
      log("rtpCapabilities", rtpCapabilities);
      callback({ rtpCapabilities });
    });

    socket.on("createWebRtcTransport", async ({ sender }, callback) => {
      log(`Is this a sender request? ${sender}`);
      if (sender) {
        producerTransport = (await createWebRtcTransport(
          callback
        )) as mediasoupTypes.WebRtcTransport;
      } else {
        consumerTransport = (await createWebRtcTransport(
          callback
        )) as mediasoupTypes.WebRtcTransport;
      }
    });

    socket.on("transport-connect", async ({ dtlsParameters }) => {
      log("DTLS PARAMS...", { dtlsParameters });
      await producerTransport?.connect({ dtlsParameters });
    });

    socket.on(
      "transport-produce",
      async ({ kind, rtpParameters, appData }, callback) => {
        producer = (await producerTransport?.produce({
          kind,
          rtpParameters,
        })) as mediasoupTypes.Producer;

        log("Producer ID: ", producer.id, producer.kind);

        producerTransport?.on("@producerclose", () => {
          log("transport for this producer is closed");
          producerTransport?.close();
        });

        callback({ id: producer.id });
      }
    );

    socket.on("transport-recv-connect", async ({ dtlsParameters }) => {
      log(`DTLS PARAMS: ${dtlsParameters}`);
      await consumerTransport?.connect({ dtlsParameters });
    });

    socket.on("consume", async ({ rtpCapabilities }, callback) => {
      try {
        log("starting consume");
        if (router.canConsume({ producerId: producer.id, rtpCapabilities })) {
          consumer = (await consumerTransport?.consume({
            producerId: producer.id,
            rtpCapabilities,
            paused: true,
          })) as mediasoupTypes.Consumer;

          consumer.on("transportclose", () => {
            log("transport close from consumer");
          });

          consumer.on("producerclose", () => {
            log("producer of consumer closed");
          });

          const params = {
            id: consumer.id,
            producerId: producer.id,
            kind: consumer.kind,
            rtpParameters: consumer.rtpParameters,
          };

          callback({ params });
        } else {
          log("router cannot consume");
        }
      } catch (error) {
        log(error);
        callback({
          params: {
            error: error,
          },
        });
      }
    });

    socket.on("consumer-resume", async () => {
      log("consumer resume");
      await consumer.resume();
    });
  });
};
